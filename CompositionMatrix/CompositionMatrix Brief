# CompositionMatrix - Generative Harmony Engine for Disting NT

**Revised Brief** - Simplified, achievable design based on lessons from VFader, VSeq, and VLoop

## Project Vision

A practical generative music engine for the Disting NT that creates harmonically-aware melodic and rhythmic patterns. The focus is on immediate playability and musical usefulness rather than complexity.

## Lessons Learned from Previous Projects

**From VLoop:**
- Real-time operation requires careful memory management (24KB SRAM limit)
- DRAM can store larger datasets (patterns, presets)
- Continuous timing at sub-pulse resolution is critical
- Simple, focused features are better than complex systems

**From VSeq:**
- 32 steps is a practical limit for pattern length
- Multiple sequencers sharing clock infrastructure works well
- Section looping provides musical variation without complexity
- Visual feedback is essential (step indicators, current position)

**From VFader:**
- Parameter organization in pages keeps UI manageable
- Trigger-on-change detection works better than continuous monitoring
- Preset serialization should be simple and robust

## Revised Core Concept

A **4-voice generative sequencer** with harmonic awareness:
- **1 Lead voice** (melodic)
- **1 Bass voice** (harmonic root)
- **2 Chord voices** (harmonic support)
- **32-step patterns** per voice
- **Clock-synchronized** with external clock input
- **Key/Scale aware** - all notes constrained to selected scale
- **Pattern memory** - save/load patterns to DRAM slots

## Simplified Architecture

### Generation Engine
Instead of a complex shift register system:
- **Deterministic random** using seed value
- **Scale-constrained** note selection
- **Rhythm patterns** based on euclidean distributions
- **Per-voice parameters**: density, octave range, gate length

### Memory Structure (SRAM)
```
struct Voice {
    int16_t notes[32];      // 64 bytes per voice
    bool gates[32];         // 32 bytes per voice
    uint8_t velocities[32]; // 32 bytes per voice
};

struct Pattern {
    Voice voices[4];        // 512 bytes for 4 voices
    uint32_t seed;          // Pattern seed
    // ... configuration params
};
```
Current pattern in SRAM (~1KB), saved patterns in DRAM

### Outputs
- **4 CV outputs** (pitch for each voice)
- **4 Gate outputs** (gates for each voice)
- **MIDI output** (optional, all 4 voices on channels 1-4)

### UI Workflow

**Mode 1: Explore (Generate)**
- Algorithm generates new pattern every N bars
- All parameters live and editable
- Encoder selects voice to edit
- Display shows current pattern and notes

**Mode 2: Refine (Edit)**
- Press encoder to freeze current pattern
- Edit individual steps per voice
- Adjust per-voice density, range, etc.
- Visual step editor similar to VSeq

**Mode 3: Save/Load**
- Save current pattern to slot (0-9) in DRAM
- Load pattern from slot
- Duplicate pattern to new slot for variation

## Parameters (Simplified)

### Global
- **Clock In** (CV input)
- **Reset** (CV input)
- **Key** (C, C#, D... B)
- **Scale** (Major, Minor, Dorian, etc.)
- **Tempo Division** (/4, /2, x1, x2, x4)
- **Pattern Length** (8, 16, 24, 32 steps)

### Per Voice (4 voices × parameters)
- **Active** (On/Off)
- **Density** (0-100% - probability of note playing)
- **Octave Min** (0-6)
- **Octave Max** (0-6)
- **Gate Length** (1-99ms)
- **Velocity** (0-127)

### Pattern Control
- **Generate** (Trigger new pattern)
- **Pattern Seed** (0-65535 for repeatability)
- **Save Slot** (0-9)
- **Load Slot** (0-9)

## Development Phases

### Phase 1: Single Voice Generator (MVP)
- Clock input and sync
- Single voice with 32-step pattern
- Scale-constrained note generation
- CV pitch + gate output
- Deterministic random from seed
- **Goal**: Prove generative concept works

### Phase 2: 4-Voice Polyphony
- Add 3 more voices
- Independent density/range per voice
- 4 × CV + Gate outputs
- UI for voice selection and editing
- **Goal**: Multi-voice harmony generation

### Phase 3: Pattern Memory
- Save/load to DRAM slots (10 patterns)
- Preset serialization
- Pattern seed display and manual entry
- **Goal**: Pattern library management

### Phase 4: Performance Features
- Pattern length variation (8/16/24/32)
- Euclidean rhythm patterns option
- Fill/variation trigger
- Clock division/multiplication
- **Goal**: Live performance tools

### Phase 5: Optional MIDI
- MIDI output for all voices
- Channels 1-4 for voices 1-4
- Note on/off with velocity
- **Goal**: Integration with MIDI gear

## What Was Removed (and Why)

❌ **Song mode / 50-slot arranger** - Too complex, use Disting's preset system instead
❌ **8 voices** - 4 voices is plenty, saves memory and CPU
❌ **Chaos parameters** - Complexity without clear musical benefit
❌ **Multiple harmony engines** - One scale system is enough
❌ **Shift register LFSR** - Simpler random works fine
❌ **SD card logging** - Use preset files for debugging
❌ **Duplicate function** - Just save to different slot
❌ **Explore mode auto-advance** - User triggers new patterns

## What Makes This Achievable

✅ **Fits in memory** - ~1KB SRAM + DRAM for pattern storage
✅ **Simple UI** - Similar to VSeq step editing
✅ **Clock-based** - Proven timing system from VSeq/VLoop
✅ **Scale-constrained** - Musical by default
✅ **Deterministic** - Seed-based generation is repeatable
✅ **Incremental** - Each phase is testable
✅ **Focused** - Does one thing well (generative harmony)

## Success Criteria

**Phase 1 Complete When:**
- Single voice generates scale-constrained notes
- Clock input advances steps correctly
- Seed changes produce different but repeatable patterns
- CV pitch output is accurate (V/oct)

**Final Product Success:**
- 4 voices play harmonically-related melodies
- Patterns are musically interesting and varied
- Save/load works reliably across power cycles
- Performance is stable with no audio glitches
- UI is intuitive and responsive

## Technical Notes

- Use `rand()` with `srand(seed)` for deterministic generation
- Scale lookup table: `const int scales[7][7]` for common scales
- Note generation: `rootNote + scales[scaleType][step % 7] + (octave * 12)`
- Pattern stored as MIDI note numbers (0-127), converted to V/oct for CV
- Gate timing: millisecond counter decremented each audio frame
- DRAM usage: 512 bytes × 10 patterns = 5KB (plenty of space)
